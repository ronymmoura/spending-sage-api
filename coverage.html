
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sage: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ronymmoura/spending-sage-api/cmd/sage/sage.go (0.0%)</option>
				
				<option value="file1">github.com/ronymmoura/spending-sage-api/internal/api/auth.go (0.0%)</option>
				
				<option value="file2">github.com/ronymmoura/spending-sage-api/internal/api/middleware.go (0.0%)</option>
				
				<option value="file3">github.com/ronymmoura/spending-sage-api/internal/api/server.go (0.0%)</option>
				
				<option value="file4">github.com/ronymmoura/spending-sage-api/internal/api/user.go (0.0%)</option>
				
				<option value="file5">github.com/ronymmoura/spending-sage-api/internal/auth/clerk/clerk.go (0.0%)</option>
				
				<option value="file6">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/categories.sql.go (87.0%)</option>
				
				<option value="file7">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/db.go (50.0%)</option>
				
				<option value="file8">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/fixed_entries.go (76.9%)</option>
				
				<option value="file9">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/fixed_entries.sql.go (100.0%)</option>
				
				<option value="file10">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/fixed_entry_payment_history.sql.go (87.0%)</option>
				
				<option value="file11">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/month_entries.go (76.9%)</option>
				
				<option value="file12">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/month_entries.sql.go (100.0%)</option>
				
				<option value="file13">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/months.sql.go (87.0%)</option>
				
				<option value="file14">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/origins.sql.go (87.0%)</option>
				
				<option value="file15">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/store.go (10.0%)</option>
				
				<option value="file16">github.com/ronymmoura/spending-sage-api/internal/db/sqlc/users.sql.go (100.0%)</option>
				
				<option value="file17">github.com/ronymmoura/spending-sage-api/internal/util/config.go (100.0%)</option>
				
				<option value="file18">github.com/ronymmoura/spending-sage-api/internal/util/random.go (100.0%)</option>
				
				<option value="file19">github.com/ronymmoura/spending-sage-api/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "github.com/ronymmoura/spending-sage-api/internal/api"
        "github.com/ronymmoura/spending-sage-api/internal/util"
)

func Run() <span class="cov0" title="0">{
        config, err := util.LoadConfig(".env")
        if err != nil </span><span class="cov0" title="0">{
                panic("Error loading config file")</span>
        }

        <span class="cov0" title="0">server, err := api.NewServer(config)
        if err != nil </span><span class="cov0" title="0">{
                panic("Opa")</span>
        }

        <span class="cov0" title="0">server.Start(":8080")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
        auth "github.com/ronymmoura/spending-sage-api/internal/auth/clerk"
)

func (server *Server) signIn(ctx *gin.Context) <span class="cov0" title="0">{
        var event auth.ClerkEvent

        if err := ctx.ShouldBindBodyWithJSON(&amp;event); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov0" title="0">if event.Type == "user.created" </span><span class="cov0" title="0">{
                auth.CreateUser(event)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/clerk/clerk-sdk-go/v2/jwt"
        "github.com/clerk/clerk-sdk-go/v2/user"
        "github.com/gin-gonic/gin"
)

const (
        authorizationHeaderKey  = "authorization"
        authorizationTypeBearer = "bearer"
        authorizationPayloadKey = "authorization_payload"
)

func authMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                authorizationHeader := ctx.GetHeader(authorizationHeaderKey)

                if len(authorizationHeader) == 0 </span><span class="cov0" title="0">{
                        err := errors.New("authorization header is not provided")
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov0" title="0">fields := strings.Fields(authorizationHeader)
                if len(fields) &lt; 2 </span><span class="cov0" title="0">{
                        err := errors.New("invalid authorization header format")
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov0" title="0">authorizationType := strings.ToLower(fields[0])
                if authorizationType != authorizationTypeBearer </span><span class="cov0" title="0">{
                        err := fmt.Errorf("unsupported authorization type %s", authorizationType)
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov0" title="0">sessionToken := strings.TrimPrefix(fields[1], "Bearer ")
                claims, err := jwt.Verify(ctx, &amp;jwt.VerifyParams{
                        Token: sessionToken,
                })

                if err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov0" title="0">usr, err := user.Get(ctx, claims.Subject)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusInternalServerError, errorResponse(err))
                        return
                }</span>

                <span class="cov0" title="0">ctx.Set(authorizationPayloadKey, usr)
                ctx.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "time"

        "github.com/clerk/clerk-sdk-go/v2"
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "github.com/ronymmoura/spending-sage-api/internal/util"
)

type Server struct {
        router *gin.Engine
        config util.Config
}

func NewServer(config util.Config) (server *Server, err error) <span class="cov0" title="0">{
        clerk.SetKey(config.ClerkKey)

        server = &amp;Server{
                config: config,
        }

        server.setupRouter()

        return
}</span>

func (server *Server) Start(address string) error <span class="cov0" title="0">{
        return server.router.Run(address)
}</span>

func (server *Server) setupRouter() <span class="cov0" title="0">{
        if server.config.Environment == "development" </span><span class="cov0" title="0">{
                gin.SetMode("debug")
        }</span> else<span class="cov0" title="0"> {
                gin.SetMode("release")
        }</span>

        <span class="cov0" title="0">router := gin.Default()

        router.Use(cors.New(cors.Config{
                AllowOrigins:     []string{"*"},
                AllowMethods:     []string{"*"},
                AllowHeaders:     []string{"*"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: true,
                AllowOriginFunc: func(origin string) bool </span><span class="cov0" title="0">{
                        return origin == "*"
                }</span>,
                MaxAge: 12 * time.Hour,
        }))

        <span class="cov0" title="0">router.POST("auth/signIn", server.signIn)

        protectedRoutes := router.Group("/").Use(authMiddleware())

        protectedRoutes.GET("/user", server.getUser)

        server.router = router</span>
}

func errorResponse(err error) gin.H <span class="cov0" title="0">{
        return gin.H{"error": err.Error()}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "net/http"

        _ "github.com/clerk/clerk-sdk-go/v2"
        _ "github.com/clerk/clerk-sdk-go/v2/jwt"
        _ "github.com/clerk/clerk-sdk-go/v2/user"
        "github.com/gin-gonic/gin"
)

func (server *Server) getUser(ctx *gin.Context) <span class="cov0" title="0">{
        authPayload := ctx.MustGet(authorizationPayloadKey)
        ctx.JSON(http.StatusOK, authPayload)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import "fmt"

type ClerkEvent struct {
        Data ClerkUserData `json:"data"`
        Type string        `json:"type"`
}

type ClerkUserData struct {
        ID             string                        `json:"id"`
        Banned         bool                          `json:"banned"`
        FirstName      string                        `json:"first_name"`
        LastName       string                        `json:"last_name"`
        EmailAddresses []ClerkUserDataEmailAddresses `json:"email_addresses"`
}

type ClerkUserDataEmailAddresses struct {
        Email string `json:"email_address"`
}

func CreateUser(event ClerkEvent) <span class="cov0" title="0">{
        fmt.Printf("name: %s\n", event.Data.FirstName)
        fmt.Printf("email: %s\n", event.Data.EmailAddresses[0].Email)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: categories.sql

package db

import (
        "context"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
  name
)
VALUES (
  $1
)
RETURNING id, name
`

func (q *Queries) CreateCategory(ctx context.Context, name string) (Category, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createCategory, name)
        var i Category
        err := row.Scan(&amp;i.ID, &amp;i.Name)
        return i, err
}</span>

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteCategory, id)
        return err
}</span>

const getCategory = `-- name: GetCategory :one
SELECT id, name
FROM categories
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCategory(ctx context.Context, id int64) (Category, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getCategory, id)
        var i Category
        err := row.Scan(&amp;i.ID, &amp;i.Name)
        return i, err
}</span>

const listCategories = `-- name: ListCategories :many
SELECT id, name
FROM categories
ORDER BY name ASC
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, listCategories)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Category{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Category
                if err := rows.Scan(&amp;i.ID, &amp;i.Name); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package db

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package db

import (
        "context"
        "database/sql"
)

const searchFixedEntries = `-- name: ListFixedEntries :many
SELECT id, user_id, name, due_date, pay_day, amount, owner, origin_id, category_id
FROM fixed_entries
WHERE user_id = $1
  AND (origin_id = $2 OR $2 IS NULL)
  AND (category_id = $3 OR $3 IS NULL)
  AND (owner = $4 OR $4 IS NULL)
ORDER BY due_date ASC
`

type SearchFixedEntriesParams struct {
        UserID     int64          `json:"user_id"`
        OriginID   sql.NullInt64  `json:"origin_id"`
        CategoryID sql.NullInt64  `json:"category_id"`
        Owner      sql.NullString `json:"owner"`
}

func (q *Queries) SearchFixedEntries(ctx context.Context, arg SearchFixedEntriesParams) ([]FixedEntry, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, searchFixedEntries,
                arg.UserID,
                arg.OriginID,
                arg.CategoryID,
                arg.Owner,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []FixedEntry{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i FixedEntry
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.Name,
                        &amp;i.DueDate,
                        &amp;i.PayDay,
                        &amp;i.Amount,
                        &amp;i.Owner,
                        &amp;i.OriginID,
                        &amp;i.CategoryID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: fixed_entries.sql

package db

import (
        "context"
        "time"
)

const createFixedEntry = `-- name: CreateFixedEntry :one
INSERT INTO fixed_entries (
  user_id,
  origin_id,
  category_id,
  name,
  due_date,
  pay_day,
  amount,
  owner
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8
)
RETURNING id, user_id, name, due_date, pay_day, amount, owner, origin_id, category_id
`

type CreateFixedEntryParams struct {
        UserID     int64     `json:"user_id"`
        OriginID   int64     `json:"origin_id"`
        CategoryID int64     `json:"category_id"`
        Name       string    `json:"name"`
        DueDate    time.Time `json:"due_date"`
        PayDay     time.Time `json:"pay_day"`
        Amount     int32     `json:"amount"`
        Owner      string    `json:"owner"`
}

func (q *Queries) CreateFixedEntry(ctx context.Context, arg CreateFixedEntryParams) (FixedEntry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createFixedEntry,
                arg.UserID,
                arg.OriginID,
                arg.CategoryID,
                arg.Name,
                arg.DueDate,
                arg.PayDay,
                arg.Amount,
                arg.Owner,
        )
        var i FixedEntry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Name,
                &amp;i.DueDate,
                &amp;i.PayDay,
                &amp;i.Amount,
                &amp;i.Owner,
                &amp;i.OriginID,
                &amp;i.CategoryID,
        )
        return i, err
}</span>

const deleteFixedEntry = `-- name: DeleteFixedEntry :exec
DELETE FROM fixed_entries
WHERE id = $1
`

func (q *Queries) DeleteFixedEntry(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteFixedEntry, id)
        return err
}</span>

const editFixedEntry = `-- name: EditFixedEntry :one
UPDATE fixed_entries
SET name = $2,
    due_date = $3,
    pay_day = $4,
    amount = $5,
    owner = $6,
    origin_id = $7,
    category_id = $8
WHERE id = $1
RETURNING id, user_id, name, due_date, pay_day, amount, owner, origin_id, category_id
`

type EditFixedEntryParams struct {
        ID         int64     `json:"id"`
        Name       string    `json:"name"`
        DueDate    time.Time `json:"due_date"`
        PayDay     time.Time `json:"pay_day"`
        Amount     int32     `json:"amount"`
        Owner      string    `json:"owner"`
        OriginID   int64     `json:"origin_id"`
        CategoryID int64     `json:"category_id"`
}

func (q *Queries) EditFixedEntry(ctx context.Context, arg EditFixedEntryParams) (FixedEntry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, editFixedEntry,
                arg.ID,
                arg.Name,
                arg.DueDate,
                arg.PayDay,
                arg.Amount,
                arg.Owner,
                arg.OriginID,
                arg.CategoryID,
        )
        var i FixedEntry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Name,
                &amp;i.DueDate,
                &amp;i.PayDay,
                &amp;i.Amount,
                &amp;i.Owner,
                &amp;i.OriginID,
                &amp;i.CategoryID,
        )
        return i, err
}</span>

const getFixedEntry = `-- name: GetFixedEntry :one
SELECT id, user_id, name, due_date, pay_day, amount, owner, origin_id, category_id
FROM fixed_entries
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetFixedEntry(ctx context.Context, id int64) (FixedEntry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getFixedEntry, id)
        var i FixedEntry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Name,
                &amp;i.DueDate,
                &amp;i.PayDay,
                &amp;i.Amount,
                &amp;i.Owner,
                &amp;i.OriginID,
                &amp;i.CategoryID,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: fixed_entry_payment_history.sql

package db

import (
        "context"
        "time"
)

const createFixedEntryPaymentHistory = `-- name: CreateFixedEntryPaymentHistory :one
INSERT INTO fixed_entry_payment_history (
  entry_id,
  amount,
  date
)
VALUES (
  $1,
  $2,
  $3
)
RETURNING id, entry_id, amount, date
`

type CreateFixedEntryPaymentHistoryParams struct {
        EntryID int64     `json:"entry_id"`
        Amount  int32     `json:"amount"`
        Date    time.Time `json:"date"`
}

func (q *Queries) CreateFixedEntryPaymentHistory(ctx context.Context, arg CreateFixedEntryPaymentHistoryParams) (FixedEntryPaymentHistory, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createFixedEntryPaymentHistory, arg.EntryID, arg.Amount, arg.Date)
        var i FixedEntryPaymentHistory
        err := row.Scan(
                &amp;i.ID,
                &amp;i.EntryID,
                &amp;i.Amount,
                &amp;i.Date,
        )
        return i, err
}</span>

const deleteFixedEntryPaymentHistory = `-- name: DeleteFixedEntryPaymentHistory :exec
DELETE FROM fixed_entry_payment_history
WHERE id = $1
`

func (q *Queries) DeleteFixedEntryPaymentHistory(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteFixedEntryPaymentHistory, id)
        return err
}</span>

const getFixedEntryPaymentHistory = `-- name: GetFixedEntryPaymentHistory :one
SELECT id, entry_id, amount, date
FROM fixed_entry_payment_history
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetFixedEntryPaymentHistory(ctx context.Context, id int64) (FixedEntryPaymentHistory, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getFixedEntryPaymentHistory, id)
        var i FixedEntryPaymentHistory
        err := row.Scan(
                &amp;i.ID,
                &amp;i.EntryID,
                &amp;i.Amount,
                &amp;i.Date,
        )
        return i, err
}</span>

const listFixedEntryPaymentHistory = `-- name: ListFixedEntryPaymentHistory :many
SELECT id, entry_id, amount, date
FROM fixed_entry_payment_history
WHERE entry_id = $1
`

func (q *Queries) ListFixedEntryPaymentHistory(ctx context.Context, entryID int64) ([]FixedEntryPaymentHistory, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, listFixedEntryPaymentHistory, entryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []FixedEntryPaymentHistory{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i FixedEntryPaymentHistory
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.EntryID,
                        &amp;i.Amount,
                        &amp;i.Date,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package db

import (
        "context"
        "database/sql"
)

const searchMonthEntries = `-- name: ListMonthEntries :many
SELECT id, month_id, name, due_date, pay_date, amount, owner, origin_id, category_id
FROM month_entries
WHERE month_id = $1
  AND (origin_id = $2 OR $2 IS NULL)
  AND (category_id = $3 OR $3 IS NULL)
  AND (owner = $4 OR $4 IS NULL)
ORDER BY due_date ASC
`

type SearchMonthEntriesParams struct {
        MonthID    int64          `json:"month_id"`
        OriginID   sql.NullInt64  `json:"origin_id"`
        CategoryID sql.NullInt64  `json:"category_id"`
        Owner      sql.NullString `json:"owner"`
}

func (q *Queries) SearchMonthEntries(ctx context.Context, arg SearchMonthEntriesParams) ([]MonthEntry, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, searchMonthEntries,
                arg.MonthID,
                arg.OriginID,
                arg.CategoryID,
                arg.Owner,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []MonthEntry{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i MonthEntry
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.MonthID,
                        &amp;i.Name,
                        &amp;i.DueDate,
                        &amp;i.PayDate,
                        &amp;i.Amount,
                        &amp;i.Owner,
                        &amp;i.OriginID,
                        &amp;i.CategoryID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: month_entries.sql

package db

import (
        "context"
        "time"
)

const createMonthEntry = `-- name: CreateMonthEntry :one
INSERT INTO month_entries (
  month_id,
  origin_id,
  category_id,
  name,
  due_date,
  pay_date,
  amount,
  owner
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8
)
RETURNING id, month_id, name, due_date, pay_date, amount, owner, origin_id, category_id
`

type CreateMonthEntryParams struct {
        MonthID    int64     `json:"month_id"`
        OriginID   int64     `json:"origin_id"`
        CategoryID int64     `json:"category_id"`
        Name       string    `json:"name"`
        DueDate    time.Time `json:"due_date"`
        PayDate    time.Time `json:"pay_date"`
        Amount     int32     `json:"amount"`
        Owner      string    `json:"owner"`
}

func (q *Queries) CreateMonthEntry(ctx context.Context, arg CreateMonthEntryParams) (MonthEntry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createMonthEntry,
                arg.MonthID,
                arg.OriginID,
                arg.CategoryID,
                arg.Name,
                arg.DueDate,
                arg.PayDate,
                arg.Amount,
                arg.Owner,
        )
        var i MonthEntry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.MonthID,
                &amp;i.Name,
                &amp;i.DueDate,
                &amp;i.PayDate,
                &amp;i.Amount,
                &amp;i.Owner,
                &amp;i.OriginID,
                &amp;i.CategoryID,
        )
        return i, err
}</span>

const deleteMonthEntry = `-- name: DeleteMonthEntry :exec
DELETE FROM month_entries
WHERE id = $1
`

func (q *Queries) DeleteMonthEntry(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteMonthEntry, id)
        return err
}</span>

const editMonthEntry = `-- name: EditMonthEntry :one
UPDATE month_entries
SET name = $2,
    due_date = $3,
    pay_date = $4,
    amount = $5,
    owner = $6,
    origin_id = $7,
    category_id = $8
WHERE id = $1
RETURNING id, month_id, name, due_date, pay_date, amount, owner, origin_id, category_id
`

type EditMonthEntryParams struct {
        ID         int64     `json:"id"`
        Name       string    `json:"name"`
        DueDate    time.Time `json:"due_date"`
        PayDate    time.Time `json:"pay_date"`
        Amount     int32     `json:"amount"`
        Owner      string    `json:"owner"`
        OriginID   int64     `json:"origin_id"`
        CategoryID int64     `json:"category_id"`
}

func (q *Queries) EditMonthEntry(ctx context.Context, arg EditMonthEntryParams) (MonthEntry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, editMonthEntry,
                arg.ID,
                arg.Name,
                arg.DueDate,
                arg.PayDate,
                arg.Amount,
                arg.Owner,
                arg.OriginID,
                arg.CategoryID,
        )
        var i MonthEntry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.MonthID,
                &amp;i.Name,
                &amp;i.DueDate,
                &amp;i.PayDate,
                &amp;i.Amount,
                &amp;i.Owner,
                &amp;i.OriginID,
                &amp;i.CategoryID,
        )
        return i, err
}</span>

const getMonthEntry = `-- name: GetMonthEntry :one
SELECT id, month_id, name, due_date, pay_date, amount, owner, origin_id, category_id
FROM month_entries
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetMonthEntry(ctx context.Context, id int64) (MonthEntry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getMonthEntry, id)
        var i MonthEntry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.MonthID,
                &amp;i.Name,
                &amp;i.DueDate,
                &amp;i.PayDate,
                &amp;i.Amount,
                &amp;i.Owner,
                &amp;i.OriginID,
                &amp;i.CategoryID,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: months.sql

package db

import (
        "context"
        "time"
)

const createMonth = `-- name: CreateMonth :one
INSERT INTO months (
  user_id,
  date
)
VALUES (
  $1,
  $2
)
RETURNING id, user_id, date
`

type CreateMonthParams struct {
        UserID int64     `json:"user_id"`
        Date   time.Time `json:"date"`
}

func (q *Queries) CreateMonth(ctx context.Context, arg CreateMonthParams) (Month, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createMonth, arg.UserID, arg.Date)
        var i Month
        err := row.Scan(&amp;i.ID, &amp;i.UserID, &amp;i.Date)
        return i, err
}</span>

const deleteMonth = `-- name: DeleteMonth :exec
DELETE FROM months
WHERE id = $1
`

func (q *Queries) DeleteMonth(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteMonth, id)
        return err
}</span>

const getMonth = `-- name: GetMonth :one
SELECT id, user_id, date
FROM months
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetMonth(ctx context.Context, id int64) (Month, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getMonth, id)
        var i Month
        err := row.Scan(&amp;i.ID, &amp;i.UserID, &amp;i.Date)
        return i, err
}</span>

const listMonths = `-- name: ListMonths :many
SELECT id, user_id, date
FROM months
WHERE user_id = $1
ORDER BY date DESC
LIMIT $2
OFFSET $3
`

type ListMonthsParams struct {
        UserID int64 `json:"user_id"`
        Limit  int32 `json:"limit"`
        Offset int32 `json:"offset"`
}

func (q *Queries) ListMonths(ctx context.Context, arg ListMonthsParams) ([]Month, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, listMonths, arg.UserID, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Month{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Month
                if err := rows.Scan(&amp;i.ID, &amp;i.UserID, &amp;i.Date); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: origins.sql

package db

import (
        "context"
)

const createOrigin = `-- name: CreateOrigin :one
INSERT INTO origins (
  name,
  type
)
VALUES (
  $1,
  $2
)
RETURNING id, name, type
`

type CreateOriginParams struct {
        Name string `json:"name"`
        Type string `json:"type"`
}

func (q *Queries) CreateOrigin(ctx context.Context, arg CreateOriginParams) (Origin, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createOrigin, arg.Name, arg.Type)
        var i Origin
        err := row.Scan(&amp;i.ID, &amp;i.Name, &amp;i.Type)
        return i, err
}</span>

const deleteOrigin = `-- name: DeleteOrigin :exec
DELETE FROM origins
WHERE id = $1
`

func (q *Queries) DeleteOrigin(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteOrigin, id)
        return err
}</span>

const getOrigin = `-- name: GetOrigin :one
SELECT id, name, type
FROM origins
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetOrigin(ctx context.Context, id int64) (Origin, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getOrigin, id)
        var i Origin
        err := row.Scan(&amp;i.ID, &amp;i.Name, &amp;i.Type)
        return i, err
}</span>

const listOrigins = `-- name: ListOrigins :many
SELECT id, name, type
FROM origins
`

func (q *Queries) ListOrigins(ctx context.Context) ([]Origin, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, listOrigins)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Origin{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Origin
                if err := rows.Scan(&amp;i.ID, &amp;i.Name, &amp;i.Type); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package db

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

type Store interface {
        Querier

        SearchMonthEntries(context.Context, SearchMonthEntriesParams) ([]MonthEntry, error)
        SearchFixedEntries(context.Context, SearchFixedEntriesParams) ([]FixedEntry, error)
}

type SQLStore struct {
        connPool *pgxpool.Pool
        *Queries
}

func NewStore(connPool *pgxpool.Pool) Store <span class="cov8" title="1">{
        return &amp;SQLStore{
                connPool: connPool,
                Queries:  New(connPool),
        }
}</span>

func (store *SQLStore) execTx(ctx context.Context, fn func(*Queries) error) error <span class="cov0" title="0">{
        tx, err := store.connPool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">q := New(tx)

        if err = fn(q); err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("transaction error: %v, rollback error: %v", err, rbErr)
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package db

import (
        "context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  email,
  full_name
)
VALUES (
  $1,
  $2
)
RETURNING id, email, full_name, created_at
`

type CreateUserParams struct {
        Email    string `json:"email"`
        FullName string `json:"full_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createUser, arg.Email, arg.FullName)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.FullName,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteUser, id)
        return err
}</span>

const getUser = `-- name: GetUser :one
SELECT id, email, full_name, created_at
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getUser, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.FullName,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, full_name, created_at
FROM users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.FullName,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package util

import (
        "fmt"

        "github.com/spf13/viper"
)

type Config struct {
        Environment      string `mapstructure:"ENVIRONMENT"`
        DatabaseHost     string `mapstructure:"DATABASE_HOST"`
        DatabaseName     string `mapstructure:"DATABASE_NAME"`
        DatabaseUser     string `mapstructure:"DATABASE_USER"`
        DatabasePassword string `mapstructure:"DATABASE_PASSWORD"`
        DatabasePort     int    `mapstructure:"DATABASE_PORT"`
        ClerkKey         string `mapstructure:"CLERK_KEY"`

        DatabaseUrl string
}

func LoadConfig(path string) (config Config, err error) <span class="cov8" title="1">{
        viper.SetConfigFile(path)

        viper.AutomaticEnv()

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">err = viper.Unmarshal(&amp;config)

        config.DatabaseUrl = fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable", config.DatabaseUser, config.DatabasePassword, config.DatabaseHost, config.DatabasePort, config.DatabaseName)

        return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package util

import (
        "fmt"
        "math"
        "math/rand"
        "strings"
        "time"
)

const alphabet = "abcdefghijklmnopqrstuvwxyz"

func init() <span class="cov8" title="1">{
        rand.NewSource(time.Now().UnixNano())
}</span>

func RandomInt(min, max int64) int64 <span class="cov8" title="1">{
        return min + rand.Int63n(max-min+1)
}</span>

func RandomFloat(min, max float64) float64 <span class="cov8" title="1">{
        return math.Round((min + rand.Float64()*(max-min)*100)) / 100
}</span>

func RandomString(size int) string <span class="cov8" title="1">{
        var sb strings.Builder
        k := len(alphabet)

        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                c := alphabet[rand.Intn(k)]
                sb.WriteByte(c)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

func RandomOwner() string <span class="cov8" title="1">{
        return RandomString(6)
}</span>

func RandomMoney() float64 <span class="cov8" title="1">{
        return RandomFloat(1, 1000)
}</span>

func RandomEmail() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s@%s.%s", RandomString(10), RandomString(5), "com")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import cmd "github.com/ronymmoura/spending-sage-api/cmd/sage"

func main() <span class="cov0" title="0">{
        cmd.Run()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
